#+TITLE:Disentangle Things (overflow)
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Data Operation
*** COMMENT aggregate-list-of-dfs
#+name:aggregate
#+begin_src R :session *R* :tangle no :exports none :eval no
  #### name:aggregate####
  # stoopid hack for lu
  # desc
  "I have a do.call question that perhaps you can answer in 5 seconds... [my brain is leaking... I can't see the solution].
  
  I have a list of data.frames imagine I wanted to sum them up, like d1+d2+... N. If I do that manually the output is a data.frame, but when I use do.call I get one number, and I need a data.frame instead.
  
  Another issues is that some columns have a factor, so I'm planning to wrap my operation into a function with a condition to do the sum if the cell contains a number. Other to skip it.
  so I though of:
  
  foo = function (x) { ifelse(is.numeric(x), sum(x), NA)} #but it doesn't work
  
  This example addressed the issues.
  
  d1 = mtcars
  d2 = d1*2
  
  str(mtcars)
  l1 = list(d1,d2)
  str(l1)
  
  d3 = do.call('sum', l1)
  #> d3
  #[1] 41826.61 # I don't want one number, but a data.frame with the sums.
  
  foo = function (x) { ifelse(is.numeric(x), sum(x), NA)}
  d4 = do.call('foo', l1)
  
  Any help or tip will be welcome!"
  
  # I feel like it should be simple because R can add dataframes
  # but maybe these need to be matrices (because a data.frame is really
  # a list)
  d1 = as.matrix(mtcars)
  d1
  d2 = as.matrix(d1*2)
  d2
  d1 + d2
  # lets make more dfs
  d3 = as.matrix(d2*3)
  d4 = as.matrix(d3*2)
  d1+d2+d3+d4
  # I note that do.call can add two df fine
  l1  <- list(d1, d2)
  out  <- do.call("+", l1)
  str(out)
  out
  # but with multiple no good
  l1 = list(d1,d2, d3, d4)
  str(l1)
  out  <- do.call("+", l1)
  # when these are dataframes the error is
  ## Error in `+`(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4,  :
  ##   unused arguments (list(mpg = c(... blah blah
  # when matrices the error is
  ## Error in `+`(c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2,  :
  ##   operator needs one or two arguments
  
  
  # But the lists content are able to be combined if done individually
  out1 <- l1[[1]] + l1[[2]] + l1[[3]] + l1[[4]]
  str(out1)
  out1
  
  # make things interesting
  l1 <- list()
  for(i in 1:1000){
    #i = 1
    di  <- iris
    di[sapply(iris, is.numeric)]  <- iris[sapply(iris, is.numeric)] * sample(rnorm(100,1,2), 1)
    l1[[i]]  <- di
  }
  str(l1)
  # so we could figure out a way to iterate over the dataframes with a
  # loop like
  ## for(i in 1:length(l1)){
  ##   if(i == 1){
  ##     out2 <- l1[[i]]
  ##     next
  ##   } else {
  ##     out2  <- out2 + l1[[i]]
  ##   }
  ## }
  # doesn't like factor
  #out2
  # or 
  ## d1 <- iris
  ## str(d1) # Note pesky factor column
  ## d2 <- d1
  ## # Only multiply cells that are numeric
  ## str(d2[sapply(d2, is.numeric)])
  ## d2[sapply(d2, is.numeric)] <- d2[sapply(d2, is.numeric)] * 2
  
  ## # Add another data.frame to make it interesting
  ## d3 <- d1
  ## d3[sapply(d3, is.numeric)] <- d3[sapply(d3, is.numeric)] * 3
  
  
  ## l1 = list(d1,d2, d3)
  str(l1)
  
  # Inititalise output dataframe to zero
  
  # Sum data frames
  summarise_list_dfs3 <- function(listed){
    d.results <- d1
    d.results[sapply(d.results, is.numeric)] <- 0 
    for (i in seq_along(l1)){
      d.results[sapply(d.results, is.numeric)] <-
        d.results[sapply(d.results, is.numeric)] +
        l1[[i]][sapply(l1[[i]], is.numeric)]
    }
    return(d.results)
  }
  system.time(d.results  <- summarise_list_dfs3(l1))
  str(d.results)
  
  # but we want an elegant solution that will be
  # able to give any number of dataframes, and also have
  # the issue of some variables being factor so not to be used
  
  # let's write some func
  # I like SQL for it's clarity
  library(sqldf)
  # we are basically grouping the values of each row in each df, so add
  # an id
  
  nam <- function(x){
    x$row_names <- 1:nrow(x)
    return(x)
  }
  l_df2 <- lapply(l1, nam)
  str(l_df2)
  # now construct some sql and run it.  let's make it flexible for
  # different summarising functions like sum, mean, median, stdev etc
  summarise_list_of_dfs <- function(
    list_of_dfs = l1
    ,
    summarise_fun = 'sum'
    ,
    id = 'row_names'
    ){
    if(!is.data.frame(list_of_dfs[[1]])) list_of_dfs <- lapply(list_of_dfs, as.data.frame)
    l_df2 <- lapply(list_of_dfs, nam)
    x = do.call('rbind.data.frame', l_df2)
  names(x)<-gsub("\\.", "_", names(x))
    todo <- sapply(x, 'is.numeric')
    todo <- names(x)[todo]
    todo <- todo[-which(todo == "row_names")]
    oper  <- sprintf('), %s(',summarise_fun)
    sql<-paste("sum(",paste(todo, sep = '', collapse = oper),")", sep = "")
  #sql
    out<-sqldf(
    #cat(
    sprintf("select row_names, %s
    from x
    group by row_names
    order by row_names
    ", sql)
    )
    names(x)<-gsub("_", "\\.", names(x))
    return(out)
  }
  
  # do
  #l1 <- lapply(l1, as.data.frame)
  
  system.time(qc  <- summarise_list_of_dfs(l1))
  
  str(qc)
  str(out1)
  out1  <- as.data.frame(out1)
  names(qc)<-names(out1)
  # same?
  identical(qc, out1)
  # not identical
  all(qc == out1)
  # all values are equal tho
  
  # compare to base r
  summarise_list_dfs2 <- function(listed){
    listed  <- l1
    d5=do.call('rbind',listed)
  #  str(d5)
    d5.rnames =rep(rownames(listed[[1]]),times=length(listed))
    d5$reg=d5.rnames
    d6 = aggregate(d5[sapply(d5, is.numeric)], by=list(d5$reg), FUN=sum) # I should use an
                                            # ifelse, to do this only to
                                            # numeric columns.
    return(d6)
  }
  system.time(d6 <- summarise_list_dfs2(l1))
  
  str(d6)
  row.names(d6) <- d6$Group.1
  # same?
  identical(d6, out1[sort(row.names(out1)),])
  # not identical
  all(
    d6[,-c(1)] == out1[sort(row.names(out1)),]
    )
  # looks like the integers are equal but not the doubles.
  # but a diff of the two looks same
  
  # now does it work for  mean?
  qc  <- summarise_list_of_dfs(l1, 'mean')
  # whoops, sql uses 'avg'
  qc  <- summarise_list_of_dfs(l1, 'avg')
  str(qc)
  # and stdev
  qc  <- summarise_list_of_dfs(l1, 'stdev')
  str(qc)
  # this did multiple dataframes, now try with factor variables
  str(l1)
  d1[,3] <- as.factor(d1[,3])
  d2[,3] <- as.factor(d2[,3])
  d3[,3] <- as.factor(d3[,3])
  d4[,3] <- as.factor(d4[,3])
  
  l1 = list(d1,d2, d3, d4)
  str(l1)
  qc  <- summarise_list_of_dfs(l1)
  str(qc)
  # it has just skipped that variable so this should be good to go
  # NB if the combination of all the dataframes is too big for RAM then
  # R will fail. in this case I would
  # put into a PostgreSQL database as this will use the disk rather than
  # RAM
  # this can also be used to add indexes and clustering functions to
  # speed up the calculations.
  # HTH, let me know if there is a more efficient R solution?
  
  install.packages("data.table")
  library(data.table)
  sum_ldf4 <- function(
    listed=l1
    ,
    summarise_fun  = 'sum'
                       ){
    d5=do.call('rbind',listed)
    d5.rnames =rep(rownames(listed[[1]]),times=length(listed))
    d5 <- d5[sapply(d5, is.numeric)]
    d5$reg=d5.rnames
    oper  <- sprintf('), %s(',summarise_fun)
    todo <- sapply(d5, 'is.numeric')
    todo <- names(d5)[todo] 
    sql<-paste("sum(",paste(todo, sep = '', collapse = oper),")", sep = "")
    #sql
      
    DT = data.table(d5)
    
    out <-  eval(parse(
        text = sprintf("DT[,list(%s),by=list(d5$reg)]", sql)
        ))
      
  
    return(out)
  }
  
  
  # sqldf
  o1 <- system.time(qc  <- summarise_list_of_dfs(l1))
  str(qc)
  # aggregate
  o2 <- system.time(d6 <- summarise_list_dfs2(l1))
  str(d6)
  # loop
  o3 <- system.time(d.results  <- summarise_list_dfs3(l1))
  str(d.results)
  # data.table
  o4 <- system.time(datab  <- sum_ldf4(l1))
  str(datab)
  
  # http://zvfak.blogspot.com.au/2011/03/applying-functions-on-groups-sqldf-plyr.html
  library(gplots)
  x<-c(o1[3],o2[3],o3[3],o4[3])
  balloonplot( rep("time.elapsed",5),c("sqldf","aggregate","loop", "data.table"),round(x,1), ylab ="Method", xlab="",sorted=F,dotcolor=rev(heat.colors(5)),main="time.elapsed for different methods") 
#+end_src

*** COMMENT aggregate-list-of-dfs-asRNW-code
#+name:aggregate-list-of-dfs-asRNW
#+begin_src R :session *R* :tangle no :exports none :eval no
#### name:aggregate-list-of-dfs-asRNW####
---
title: "aggregate list of dfs"
author: "Ivan C Hanigan"
date: "7/2/2015"
output: html_document
---

```{r}
#### name:aggregate####
# stoopid hack for lu
# desc
"I have a do.call question that perhaps you can answer in 5 seconds... [my brain is leaking... I can't see the solution].

I have a list of data.frames imagine I wanted to sum them up, like d1+d2+... N. If I do that manually the output is a data.frame, but when I use do.call I get one number, and I need a data.frame instead.

Another issues is that some columns have a factor, so I'm planning to wrap my operation into a function with a condition to do the sum if the cell contains a number. Other to skip it.
so I though of:

foo = function (x) { ifelse(is.numeric(x), sum(x), NA)} #but it doesn't work

This example addressed the issues.

d1 = mtcars
d2 = d1*2

str(mtcars)
l1 = list(d1,d2)
str(l1)

d3 = do.call('sum', l1)
#> d3
#[1] 41826.61 # I don't want one number, but a data.frame with the sums.

foo = function (x) { ifelse(is.numeric(x), sum(x), NA)}
d4 = do.call('foo', l1)

Any help or tip will be welcome!"

# I feel like it should be simple because R can add dataframes
# but maybe these need to be matrices (because a data.frame is really
# a list)
d1 = as.matrix(mtcars)
d1
d2 = as.matrix(d1*2)
d2
d1 + d2
# lets make more dfs
d3 = as.matrix(d2*3)
d4 = as.matrix(d3*2)
d1+d2+d3+d4
# I note that do.call can add two df fine
l1  <- list(d1, d2)
out  <- do.call("+", l1)
str(out)
out
# but with multiple no good
l1 = list(d1,d2, d3, d4)
str(l1)
#out  <- do.call("+", l1)
# when these are dataframes the error is
## Error in `+`(list(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4,  :
##   unused arguments (list(mpg = c(... blah blah
# when matrices the error is
## Error in `+`(c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2,  :
##   operator needs one or two arguments


# But the lists content are able to be combined if done individually
out1 <- l1[[1]] + l1[[2]] + l1[[3]] + l1[[4]]
str(out1)
out1

# make things interesting
l1 <- list()
for(i in 1:1000){
  #i = 1
  di  <- iris
  di[sapply(iris, is.numeric)]  <- iris[sapply(iris, is.numeric)] * sample(rnorm(100,1,2), 1)
  l1[[i]]  <- di
}
str(l1)
# so we could figure out a way to iterate over the dataframes with a
# loop like
## for(i in 1:length(l1)){
##   if(i == 1){
##     out2 <- l1[[i]]
##     next
##   } else {
##     out2  <- out2 + l1[[i]]
##   }
## }
# doesn't like factor
#out2
# or 
## d1 <- iris
## str(d1) # Note pesky factor column
## d2 <- d1
## # Only multiply cells that are numeric
## str(d2[sapply(d2, is.numeric)])
## d2[sapply(d2, is.numeric)] <- d2[sapply(d2, is.numeric)] * 2

## # Add another data.frame to make it interesting
## d3 <- d1
## d3[sapply(d3, is.numeric)] <- d3[sapply(d3, is.numeric)] * 3


## l1 = list(d1,d2, d3)
str(l1)

# Inititalise output dataframe to zero

# Sum data frames
summarise_list_dfs3 <- function(
  listed=l1
  ){
  d.results <- listed[[1]]
  d.results[sapply(d.results, is.numeric)] <- 0 
  for (i in seq_along(listed)){
    d.results[sapply(d.results, is.numeric)] <-
      d.results[sapply(d.results, is.numeric)] +
      listed[[i]][sapply(listed[[i]], is.numeric)]
  }
  return(d.results)
}
system.time(d.results  <- summarise_list_dfs3(l1))
str(d.results)

# but we want an elegant solution that will be
# able to give any number of dataframes, and also have
# the issue of some variables being factor so not to be used

# let's write some func
# I like SQL for it's clarity
library(sqldf)
# we are basically grouping the values of each row in each df, so add
# an id

nam <- function(x){
  x$row_names <- 1:nrow(x)
  return(x)
}
l_df2 <- lapply(l1, nam)
str(l_df2)
# now construct some sql and run it.  let's make it flexible for
# different summarising functions like sum, mean, median, stdev etc
summarise_list_of_dfs <- function(
  list_of_dfs = l1
  ,
  summarise_fun = 'sum'
  ,
  id = 'row_names'
  ){
  if(!is.data.frame(list_of_dfs[[1]])) list_of_dfs <- lapply(list_of_dfs, as.data.frame)
  l_df2 <- lapply(list_of_dfs, nam)
  x = do.call('rbind.data.frame', l_df2)
names(x)<-gsub("\\.", "_", names(x))
  todo <- sapply(x, 'is.numeric')
  todo <- names(x)[todo]
  todo <- todo[-which(todo == "row_names")]
  oper  <- sprintf('), %s(',summarise_fun)
  sql<-paste("sum(",paste(todo, sep = '', collapse = oper),")", sep = "")
#sql
  out<-sqldf(
  #cat(
  sprintf("select row_names, %s
  from x
  group by row_names
  order by row_names
  ", sql)
  )
  names(x)<-gsub("_", "\\.", names(x))
  return(out)
}

# do
#l1 <- lapply(l1, as.data.frame)

system.time(qc  <- summarise_list_of_dfs(l1))

str(qc)
str(out1)
out1  <- as.data.frame(out1)
#names(qc)<-names(out1)
# same?
#identical(qc, out1)
# not identical
#all(qc == out1)
# all values are equal tho

# compare to base r
summarise_list_dfs2 <- function(listed){
  #listed  <- l1
  d5=do.call('rbind',listed)
#  str(d5)
  d5.rnames =rep(rownames(listed[[1]]),times=length(listed))
  d5$reg=d5.rnames
  d6 = aggregate(d5[sapply(d5, is.numeric)], by=list(d5$reg), FUN=sum) # I should use an
                                          # ifelse, to do this only to
                                          # numeric columns.
  return(d6)
}
system.time(d6 <- summarise_list_dfs2(l1))

str(d6)
row.names(d6) <- d6$Group.1
# same?
#identical(d6, out1[sort(row.names(out1)),])
# not identical
#all(
#  d6[,-c(1)] == out1[sort(row.names(out1)),]
#  )
# looks like the integers are equal but not the doubles.
# but a diff of the two looks same

# now does it work for  mean?
#qc  <- summarise_list_of_dfs(l1, 'mean')
# whoops, sql uses 'avg'
qc  <- summarise_list_of_dfs(l1, 'avg')
str(qc)
# and stdev
qc  <- summarise_list_of_dfs(l1, 'stdev')
str(qc)
# this did multiple dataframes, now try with factor variables
str(l1)
d1[,3] <- as.factor(d1[,3])
d2[,3] <- as.factor(d2[,3])
d3[,3] <- as.factor(d3[,3])
d4[,3] <- as.factor(d4[,3])

l1 = list(d1,d2, d3, d4)
str(l1)
qc  <- summarise_list_of_dfs(l1)
str(qc)
# it has just skipped that variable so this should be good to go
# NB if the combination of all the dataframes is too big for RAM then
# R will fail. in this case I would
# put into a PostgreSQL database as this will use the disk rather than
# RAM
# this can also be used to add indexes and clustering functions to
# speed up the calculations.
# HTH, let me know if there is a more efficient R solution?

#install.packages("data.table")
library(data.table)
sum_ldf4 <- function(
  listed=l1
  ,
  summarise_fun  = 'sum'
                     ){
  d5=do.call('rbind',listed)
  d5.rnames =rep(rownames(listed[[1]]),times=length(listed))
  d5 <- d5[sapply(d5, is.numeric)]
  d5$reg=d5.rnames
  oper  <- sprintf('), %s(',summarise_fun)
  todo <- sapply(d5, 'is.numeric')
  todo <- names(d5)[todo] 
  sql<-paste("sum(",paste(todo, sep = '', collapse = oper),")", sep = "")
  #sql
    
  DT = data.table(d5)
  
  out <-  eval(parse(
      text = sprintf("DT[,list(%s),by=list(d5$reg)]", sql)
      ))
    

  return(out)
}


# sqldf
o1 <- system.time(qc  <- summarise_list_of_dfs(l1))
str(qc)
# aggregate
o2 <- system.time(d6 <- summarise_list_dfs2(l1))
str(d6)
# loop
o3 <- system.time(d.results  <- summarise_list_dfs3(l1))
str(d.results)
# data.table
o4 <- system.time(datab  <- sum_ldf4(l1))
str(datab)

# http://zvfak.blogspot.com.au/2011/03/applying-functions-on-groups-sqldf-plyr.html
library(gplots)
x<-c(o1[3],o2[3],o3[3],o4[3])
balloonplot( rep("time.elapsed",5),c("sqldf","aggregate","loop", "data.table"),round(x,1), ylab ="Method", xlab="",sorted=F,dotcolor=rev(heat.colors(5)),main="time.elapsed for different methods") 

sessionInfo()
```



#+end_src

* Graphical User Interfaces
** web2py


*** TODO using the appadmin interface

query can be db.dataset.contact.like('Lach%')

* Project Management
** 2014-12-25-todo- detail-within-context-as-per-tuftes-gantt-alternative

*** blog

#+name:detail-within-context-as-per-tuftes-gantt-alternative-header
#+begin_src markdown :tangle ~/projects/ivanhanigan.github.com.raw/_posts/2014-12-25-todo-detail-within-context-as-per-tuftes-gantt-alternative.md :exports none :eval no :padline no
  ---
  name: todo-detail-within-context-as-per-tuftes-gantt-alternative
  layout: post
  title: todo-detail-within-context-as-per-tuftes-gantt-alternative
  date: 2014-12-25
  categories:
  -
  ---
  
  - During the end of 2015 I found that the Gantt Chart by TaskJuggler was a struggle to really achieve.
  - I decided to code up an alternative based on the theory explained on [[this link][http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=000076]] 

  
  #### Project Management Graphics (or Gantt Charts), by Edward Tufte
      Computer screens are generally too small for an overview of big
      serious projects. Horizontal and vertical scrolling are necessary to
      see more than about 40 horizontal time lines for a reasonable period
      of time. Thus, for large projects, print out the sequence on a big
      roll of paper and put it up on a wall.
       
      The chart might be retrospective as well as prospective. That is, the
      chart should show actualdates of achieved goals, evidence which will
      continuously reinforce a reality principle on the mythical future
      dates of goal achievement.
       
      Most of the Gantt charts are analytically thin, too simple, and lack
      substantive detail. The charts should be more intense. At a minimum,
      the charts should be annotated--for example, with to-do lists at
      particular points on the grid. Costs might also be included in
      appropriate cells of the table.
       
      About half the charts show their thin data in heavy grid prisons. For
      these charts the main visual statement is the administrative grid
      prison, not the actual tasks contained by the grid. No explicitly
      expressed grid is necessary--or use the ghost-grid graph
      paper. Degrid!
  
  I had been following the approach described at http://orgmode.org/worg/org-tutorials/org-taskjuggler.html and the terms there are defined:
  
  #### Blocker:
      property which allows you to state that a task depends on either
      a previous sibling ("previous-sibling") or
      any other task by stating the task_id property of the predecessor
  
  
  
  #### Code:detail-within-context-as-per-tuftes-gantt-alternative
      
#+end_src
*** todo_in_context-code
** gantt_tufte
*** COMMENT R-gantt_tufte_test_data
#+name:gantt_tufte
#+begin_src R :session *R* :tangle no :exports none :eval yes
  # func
  library(sqldf)
  library(lubridate)
  library(swishdbtools)
  ch <- connect2postgres('localhost','gantt_tufte2', 'w2p_user', p='xpassword')
  pgListTables(ch, "public")
  
  # load
  datin  <- read.csv(textConnection("container_task_title, task_id, allocated, fte, blocker, start_date, effort
  Container 1, task 0, jim,   1,   ,     2014-12-01, 1m
  Container 1, task 1, jim,   1,   ,     2014-12-20, 1m
  Container 1, task 2, bob,   1, task 1,           , 10d 
  Container 2, task 3, sue,   1,   ,     2014-12-01, 2w
  Container 2, task 4, jim,   1, task 3,           , 2d
  Container 3, task 5, jimmy, 1, task 3,           , 10d
  Container 3, task 6, jimmy, 1,       , 2015-01-01, 10d
  Container 4, task 7, jimmy, 1, task 3,           , 10d
  "),
  stringsAsFactor = F, strip.white = T)
  datin$start_date  <- as.Date(datin$start_date)
  str(datin)
  datin
  
  cnt  <- sqldf("select container_task from datin group by container_task", drv = "SQLite")
  cnt$key_contact  <- NA
  cnt$abstract  <- NA
  cnt
  dbWriteTable(ch, "container_task", cnt, append = T)
  cnt  <- dbReadTable(ch, "container_task")
  cnt
  
  paste(  names(datin), sep = "", collapse = ", ")
  datin2  <- sqldf("select id as container_id, task_id, allocated, fte, blocker, start_date, effort
  from cnt
  join datin
  on cnt.container_task_title = datin.container_task", drv = "SQLite")
  datin2
  datin2$notes_issues  <- NA
  dbWriteTable(ch, "work_package", datin2, append = T)
  
  # psql got munteded, so revert to sqlite, tried swapping to sqlite, noto
  
  ## drv <- dbDriver("SQLite")
  ## tfile <- tempfile()
  ## con <- dbConnect(drv, dbname = "~/tools/web2py/applications/gantt_tufte/databases/storage.sqlite")
  ## dbListTables(con)
  ## datin2 <- dbGetQuery(con , "select * from work_package")
  ## dbWriteTable(ch, "work_package", datin2, append = T)
  
  
  # ended up deleteing from the applications folder
  
   
#+end_src

#+RESULTS: gantt_tufte
=1
==1
==1
==2
==2
==2
==2
==2
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==2
==1
==1
==1
==1
==1
==2
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==2
==2
==1
==1
==2
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==2
==1
==1
==2
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==1
==2
==1
==1
==1
==TRUE
==1
==1
==1
==1
==1
==1
==1
==1
==1

*** COMMENT R-gantt_tufte_preprocessing
#+name:gantt_tufte
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################ 
  gantt_tufte_preprocessing  <- function(
    indat = datin
    ){
    # self join to collect the dependencies
    # paste(names(datint), sep = "", collapse = ", ")
    library(sqldf)
    library(lubridate)
    indat
    #indat$indat_id <- paste(indat$container_task, indat$task_id, sep = "_")
    # self join to return dependents
    indat2 <- sqldf("
    select t1.container_task,
    t1.task_id as predecessor,
    t2.task_id, t2.efforti,
    t1.end
    from indat t1
    left join
    indat t2
    on t1.task_id = t2.blocker
    
    ", drv = 'SQLite')
    #where t2.task_id is not null 
    indat2
    # get any other containers... not sure this helps
    indat2_1 <- sqldf("select t1.container_task, t1.predecessor, t2.predecessor as task_id,
    t2.efforti,
    t2.end
    from indat2 t1
    join
    indat2 t2
    where t1.predecessor = t2.task_id")
    indat2_1
    indat2$start  <- indat2$end 
    indat2$end  <- indat2$start + indat2$efforti
    indat2_1$start  <- indat2_1$end 
    indat2_1$end  <- indat2_1$start + indat2_1$efforti
    indat2  <- indat2[!is.na(indat2$start) & !is.na(indat2$end) ,]
    indat2
    indat2_1
    indat2 <- rbind(indat2, indat2_1)
    
    indat2 <- unique(indat2)
    # now you know the start of the dependents
    
    # now get other independent tasks
    indat3 <- sqldf("select container_task,
    task_id as predecessor,
    task_id,
    efforti,
    end, start
    from indat
    where start is not null
    ")
    # TODO at this point need to figure out how to get proper locs
    #indat3$loc <- nrow(indat3):1
    indat3
    indat2 
    # add loc of siblings
    ## indatx <- sqldf("select t1.*, t2.loc
    ## from indat2 t1
    ## left join
    ## indat3 t2
    ## where (t1.predecessor = t2.task_id)
    ## and t1.task_id is not null
    ## ")
    #indatx
    
    indat4 <- rbind(indat2, indat3)
    indat4 <- indat4[order(indat4$start),]
    indat4[order(indat4$container_task),]
    indat4 
    return(indat4)
  }
  datin2 <- indat4
  #datin2 <- gantt_tufte_preprocessing(datin)
  #str(datin2)
    
#+end_src

*** R timebox

#+name:timebox
#+begin_src R :session *R* :tangle R/timebox.R :exports none :eval yes
  #### name:timebox####
  # func to calculate time boxes
  timebox <- function(dat_in){
    # dat_in  <- datin
    if(
      !exists("dat_in$end_date")
      ) dat_in$end_date <- NA
    # str(dat_in)
    nameslist <- names(dat_in)
    dat_in$effortt <- as.numeric(gsub("[^\\d]+", "", dat_in$effort, perl=TRUE))
    dat_in$effortd <- gsub("d", 1, gsub("[[:digit:]]+", "", dat_in$effort, perl=TRUE))
    dat_in$effortd <- gsub("w", 7, dat_in$effortd)
    dat_in$effortd <- gsub("m", 30.5, dat_in$effortd)
    dat_in$effortd <- as.numeric(dat_in$effortd)
    dat_in$efforti <- dat_in$effortt * dat_in$effortd
    dat_in[is.na(dat_in$end_date),"end_date"] <- dat_in[is.na(dat_in$end_date),"start_date"] + dat_in[is.na(dat_in$end_date),"efforti"]
    dat_in$end_date  <- as.Date(dat_in$end_date, '1970-01-01')
    #   str(dat_in)
    dat_in <- dat_in[,c(nameslist, "efforti")]
    return(dat_in)
  }
  
#+end_src

#+RESULTS: timebox

*** get_gantt_data-code ETL
#+name:get_test_data
#+begin_src R :session *R* :tangle R/get_gantt_data.R :exports none :eval no
  
  library(sqldf)
  library(lubridate)
  library(swishdbtools)
  
  
  get_gantt_data <- function(
    dbname = 'gantt_todo'
    ,
    test_data = T
    ){
  if(test_data != TRUE){
  #### name:get_test_data####
  if(exists("ch"))  dbDisconnect(ch)
  ch <- connect2postgres2(dbname)
  
  datin  <- dbGetQuery(ch,
  "
  select t1.container_task_title, 
  t2.*
  from container_task t1
  join work_package t2
  on t1.id = t2.container_id
  where t2.status != 'DONTSHOW'
  order by container_task_title"
  )
  str(datin)
  datin_done  <- dbGetQuery(ch,
  "
  select t1.container_task_title, 
  t2.*
  from container_task_done t1
  join work_package_done t2
  on t1.id = t2.container_id
  where t2.status != 'DONTSHOW'
  "
  )
  str(datin_done)
  datin  <- rbind(datin, datin_done)
  } else {
  # or simpler
  datin  <- read.csv(textConnection("container_task_title, task_id, allocated, fte, blocker, start_date, effort, status, notes
    Container 1, task 0, jim,   1,   ,     2015-01-01, 1m  , DONE,  
    Container 1, task 1, jim,   1,   ,     2015-01-20, 1m  , DONE,  
    Container 1, task 2, bob,   1, task 1,           , 10d , TODO, This is a note 
    Container 2, task 3, sue,   1,   ,     2015-01-01, 2w  , TODO,  
    Container 2, task 4, jim,   1, task 3,           , 2d  , TODO,  
    Container 3, task 5, jimmy, 1, task 3,           , 10d , TODO,  
    Container 3, task 6, jimmy, 1,       , 2015-02-01, 10d , TODO,  
    Container 4, task 7, jimmy, 1, task 0,           , 10d , TODO,  
    Container 5, task 8, sue,   1,       , 2015-01-14, 5d  , TODO,  
    Container 5, task 9, sue,   1, task 8, , 2d            , TODO,  
    Container 5, task 10, sue,   1, task 9, , 2d           , TODO,  
    Container 5, task 11, sue,   1, task 10, , 2d          , TODO,  
    Container 5, task 12, sue,   1, task 11, , 2d          , TODO,  
    Container 5, task 13, sue,   1, task 12, , 2d          , TODO,  
    Container 5, task 14, sue,   1, task 13, , 2d          , TODO,  
    "),
    stringsAsFactor = F, strip.white = T)
    datin$start_date  <- as.Date(datin$start_date)
    str(datin)
    datin[datin$blocker == "","blocker"] <- NA
  # datin
  }
  
  return(datin)
  }

#+end_src

*** gantt_data_prep-code ETL
#+name:get_test_data
#+begin_src R :session *R* :tangle R/gantt_data_prep.R :exports none :eval no
  
  gantt_data_prep <- function(
    dat_in = datin
    ){
    dat_in <- timebox(dat_in)
    dat_in[1:5,c("task_id","start_date","end_date", "efforti")]
    str(dat_in)
    dat_in  <- dat_in[,c('container_task_title','task_id','allocated','fte','start_date','efforti','notes','status','blocker','end_date')]
    t(dat_in[1,])
    #dat_in
    # dbSendQuery(ch, "drop table indat")
    # dbWriteTable(ch, "indat", dat_in)
    
    indat <- dat_in
    dat_in_depends <- sqldf("
    select tab1.container_task_title, tab1.task_id, 
    'depends on ' || tab1.blocker || ' from Container ' || tab2.container_task_title as depends_on,
    tab2.end_date as start_date, 
    tab1.efforti, tab1.status
    from
    (
      select t1.container_task_title,
      t1.task_id, t1.blocker,
      t1.start_date,
      t1.end_date,
      t1.efforti, t1.status
      from indat t1
      where t1.blocker is not null
      ) tab1
    join
    indat tab2
    on tab1.blocker = tab2.task_id
    ", drv = "SQLite")
    # cast(tab2.end_date + (tab1.efforti || ' day')::INTERVAL as date) as
    # end_date
    dat_in_depends[1,]
    #dat_in_depends
    dat_in_depends$end_date  <- dat_in_depends$start_date + dat_in_depends$tab1.efforti
    names(dat_in_depends) <- gsub('tab1.', '', names(dat_in_depends))
    
    dat_in <- sqldf("
      select t1.container_task_title,
      t1.task_id, 
      t1.task_id as depends_on,  
      t1.start_date,
      t1.efforti,
      t1.status,
      t1.end_date
      from indat t1
      where t1.blocker is null or t1.blocker = ''
      order by container_task_title
    ", drv = 'SQLite')
    dat_in[,1]
    dat_in <- rbind(dat_in, dat_in_depends)
    dat_in[1,]
    #dat_in
    loc  <- sqldf("select container_task_title from dat_in group by container_task_title", drv = "SQLite")
    loc$loc  <- nrow(loc):1
    loc
    dat_in <- merge(loc, dat_in)
    str(dat_in)
    loc
    dat_out <- as.data.frame(matrix(NA, nrow = 0, ncol = ncol(dat_in) + 1))
    #names(qc) <- c(names(dat_in),"loc2")
    for(loci in loc$loc){
    # loci = loc$loc[1]
    qc <- dat_in[dat_in$loc == loci,]
    qc <- qc[order(qc$start_date),]
    loc2 <- seq(qc$loc[1]-1, qc$loc[1],  1/(length(qc$loc)))
    qc$loc2  <- loc2[(length(loc2)):2] 
    
    dat_out  <- rbind(dat_out, qc)
    
    }
    str(dat_out)
    return(dat_out)
    }
      
#+end_src

#+RESULTS: get_test_data

*** R-gantt_tufte PLOT
#+name:gantt_tufte
#+begin_src R :session *R* :tangle R/gantt_tufte.r :exports none :eval yes
  ################################################################
  # plot 
  
  gantt_tufte <- function(
    indat = dat_out
    ,
    smidge_lab = .15
    ,
    focal_date = '2015-01-18' # Sys.Date()
    , 
    show_today = TRUE
    ,
    time_box = 7 * 2.5
    ,
    end_task_ticks = F
    ,
    cex_context_ylab = 0.2
    ,
    cex_context_xlab = 0.5
    ,
    cex_context_points = 0.5
    ,
    min_context_xrange =  NA
    , 
    max_context_xrange = NA
    ,
    cex_detail_ylab = 0.7
    ,
    cex_detail_xlab = 1
    ,
    cex_detail_points = 0.7
    ,
    cex_detail_labels = 0.7
    ){
    focal_date <- as.Date(focal_date)
    m <- matrix(c(1,2), 2, 1)
    layout(m, widths=c(1), heights=c(.75,4))
    par(mar = c(3,16,2,1))
    # layout.show(2)
  
  
    yrange <- c((min(indat$loc2) - smidge_lab), (max(indat$loc2) + smidge_lab))
    if(!is.na(min_context_xrange)){
    xmin <- as.Date(min_context_xrange)    
    } else {
    xmin <- min(indat$start_date, na.rm = T)
    }
    if(!is.na(max_context_xrange)){
    xmax <- as.Date(max_context_xrange)    
    } else {
    xmax <- max(indat$start_date, na.rm = T)
    }
  
    xrange  <- c(xmin,xmax)
    
    # xrange
    #### context ####
    
    plot(xrange, yrange, type = 'n', xlab = "", ylab = "", axes = F )
    indat_lab  <- sqldf("select container_task_title, loc from indat group by container_task_title, loc", drv = "SQLite")
    mtext(c(indat_lab$container_task_title), 2, las =1, at = indat_lab$loc, cex = cex_context_ylab)
  
    polygon(c(focal_date, focal_date + time_box, focal_date + time_box, focal_date), c(rep(yrange[1],2), rep(yrange[2],2)), col = 'lightyellow', border = 'lightyellow')
  # DONE is grey
  indat_done <- indat[indat$status == 'DONE',]
    points(indat_done$start_date, indat_done$loc2, pch = 16, cex = cex_context_points, col = 'grey')
    #text(indat_done$start_date, indat_done$loc2 - smidge_lab, labels = indat_done$task_id, pos = 4)
    js <- indat_done$loc2
    for(i in 1:nrow(indat_done)){
    # = 1
      segments(indat_done$start_date[i] , js[i] , indat_done$start_date[i] , max(indat_done$loc2) + 1 , lty = 3, col = 'grey')
      segments(indat_done$start_date[i] , js[i] , indat_done$end_date[i] , js[i], col = 'grey')
    }
  # indat todo is black
  indat_todo <- indat[indat$status == 'TODO',]
    points(indat_todo$start_date, indat_todo$loc2, pch = 16, cex = cex_context_points)
    #text(indat_todo$start_date, indat_todo$loc2 - smidge_lab, labels = indat_todo$task_id, pos = 4)
    js <- indat_todo$loc2
    for(i in 1:nrow(indat_todo)){
    # = 1
      segments(indat_todo$start_date[i] , js[i] , indat_todo$start_date[i] , max(indat_todo$loc2) + 1 , lty = 3)
      segments(indat_todo$start_date[i] , js[i] , indat_todo$end_date[i] , js[i] )
    }  
    #segments(focal_date, yrange[1], focal_date, yrange[2], 'red')
    xstart_date <- ifelse(wday(xrange[1]) != 1, xrange[1] - (wday(xrange[1]) - 2), xrange[1])
    xend <- ifelse(wday(xrange[2]) != 7, xrange[2] + (5-wday(xrange[2])), xrange[2] )
    at_dates  <- seq(xstart_date, xend, 7)
    label_dates  <-
      paste(month(as.Date(at_dates, "1970-01-01"), label = T),
      day(as.Date(at_dates, "1970-01-01")),
      sep = "-")
  
    axis(1, at = at_dates, labels = label_dates, cex.axis = cex_context_xlab)
    #axis(3)
    if(show_today) segments(Sys.Date(), min(js), Sys.Date(), max(js), lty = 2, col = 'blue')
    
    #### detail ####
    js <- indat$loc2
    # todo
    plot(c(focal_date, focal_date + time_box), yrange, type = 'n', xlab = "", ylab = "", axes = F)
         
    mtext(c(indat_lab$container_task_title), 2, las =1, at = indat_lab$loc, cex = cex_detail_ylab)
    points(indat$start_date, indat$loc2, pch = 16, cex = cex_detail_points)
    text(indat$start_date, indat$loc2 - smidge_lab, labels = indat$task_id, pos = 4,
         cex = cex_detail_labels)
    for(i in 1:nrow(indat)){
    # = 1
      segments(indat$start_date[i] , js[i] , indat$start_date[i] , max(indat$loc2) + 1 , lty = 3,
        col = ifelse(indat$status[i] == "DONE", "grey","black"))
      segments(indat$start_date[i] , js[i] , indat$end_date[i] , js[i],
        col = ifelse(indat$status[i] == "DONE", "grey","black"))
    }
    # done
    indat_done  <- indat[indat$status == "DONE",]
    points(indat_done$start_date, indat_done$loc2, pch = 16, cex = cex_detail_points, col = "darkgrey")
    text(indat_done$start_date, indat_done$loc2 - smidge_lab, labels = indat_done$task_id, pos = 4,
         cex = cex_detail_labels, col = "darkgrey")  
    for(i in 1:nrow(indat_done)){
    # = 1
      segments(indat_done$start_date[i] , indat_done$loc2[i] , indat_done$start_date[i] , max(indat_done$loc2) + 1 , lty = 3, col = 'darkgrey')
      segments(indat_done$start_date[i] , indat_done$loc2[i] , indat_done$end_date[i] , indat_done$loc2[i], col = 'darkgrey' )
    }
  
    # continuing
  
    bumped_up <- indat[indat$start_date < focal_date & indat$status != 'DONE',]
    if(nrow(bumped_up) > 0){
    text(focal_date, bumped_up$loc2 - smidge_lab, labels = bumped_up$task_id, pos = 4,
         cex = cex_detail_labels, col = 'darkred')
    }
    if(nrow(bumped_up2) > 0){
    bumped_up2 <- indat[indat$start_date < focal_date & indat$status == 'DONE' & indat$end_date >= focal_date,]
    text(focal_date, bumped_up2$loc2 - smidge_lab, labels = bumped_up2$task_id, pos = 4,
         cex = cex_detail_labels, col = 'grey')
    }
    
    # overdue
    ## bumped_up <- indat[indat$end_date < focal_date & indat$status != 'DONE',]
    ## text(focal_date, bumped_up$loc2 - smidge_lab, labels = bumped_up$task_id, pos = 4,
    ##      cex = cex_detail_labels, col = 'darkorange')
    
    #segments(focal_date, yrange[1], focal_date, yrange[2], 'red')
    xstart_date <- ifelse(wday(focal_date) != 1, focal_date - (wday(focal_date) - 2), focal_date)
    xend <- ifelse(wday(focal_date + time_box) != 7, (focal_date + time_box) + (5-wday(focal_date + time_box)), (focal_date + time_box))
    at_dates  <- seq(xstart_date, xend, 1)
    at_dates2  <- seq(xstart_date, xend, 7)
    
    label_dates  <-
      paste(month(as.Date(at_dates2, "1970-01-01"), label = T),
      day(as.Date(at_dates2, "1970-01-01")),
      sep = "-")
  
    axis(1, at = at_dates, labels = F)
    axis(1, at = at_dates2, labels = label_dates,  cex = cex_detail_xlab)
    #segments(min(xrange), min(yrange) - .09, max(xrange), min(yrange) - .09)
    axis(3, at = at_dates, labels = F)
    axis(3, at = at_dates2, labels = label_dates)
    #segments(min(xrange), max(yrange) + .09, max(xrange), max(yrange) + .09)  
    if(show_today) segments(Sys.Date(), min(js), Sys.Date(), max(js) + 1, lty = 2, col = 'blue')
    
  }
  #ls()
  
#+end_src
*** man-gantt_tufte
#+name:gantt_tufte
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # arguments: gantt_tufte
  # this is a ploting function, depends on timebox and preprocessing 

  # args
  ## indat = datin4
  ## smidge_lab = .15
  ## focal_date = Sys.Date()
  ## time_box = 21
  ## end_task_ticks = F # this is the little tick marking the end of the tasks

#+end_src


      
*** test go
**** COMMENT test1-code

#+begin_src R :session *R* :tangle no :exports none :eval yes
  #### name:test2####
  source("R/timebox.R")
  source("R/get_gantt_data.R")
  source("R/gantt_data_prep.R")
  source("R/gantt_tufte.r")
  dat_in <- get_gantt_data(test_data = F)
  dat_out <- gantt_data_prep(dat_in)
  str(dat_out)
    svg("tests/AAPL.svg",height=26,width=18)
    gantt_tufte(dat_out, focal_date = "2015-01-10", cex_context_ylab = 0.45,
     min_context_xrange = "2015-01-01", time_box = 7 * 3.5, cex_detail_xlab = .4)
    dev.off()
  
  #### name:tat####
  #library(devtools)
  #install_github("ivanhanigan/disentangle")
  setwd("tests")
  require(knitr)
  require(markdown)
  opts_chunk$set(fig.align=”left”)
  knit2html("gantt_tufte_test.Rmd", options = c("toc", markdown::markdownHTMLOptions(TRUE)), stylesheet = "custom.css")
  setwd("..")
#+end_src

#+RESULTS:
: /home/ivan_hanigan/tools/disentangle/tests

: 
*** COMMENT test RMD
<section>
    <img style="float: left" src="AAPL.svg">
  </section>

#+name:make_html
#+begin_src R :session *R* :tangle tests/gantt_tufte_test.Rmd :exports none :eval yes
  Overview of Gantt Chart
  ===
  
  ivan.hanigan@anu.edu.au
  
  ```{r echo = F, eval=F, results="hide"}
  setwd("tests")
  require(knitr)
  require(markdown)
  opts_chunk$set(fig.align=”left”)
  knit2html("gantt_tufte_test.Rmd", options = c("toc", markdown::markdownHTMLOptions(TRUE)), stylesheet = "custom.css")
  ```
  
  ```{r}
  print(Sys.Date())
  ```
  
  Introduction
  ---
  
  This is a report of the TODO list broken down by LTERN Data Team member.
  
  
  ![aa](AAPL.svg)  
  
  ```{r}
  print(cat("\n"))
  ```
  
    
  ```{r echo = F, results = "hide", eval = T}
  #### name:test2####
  source("../R/timebox.R")
  source("../R/get_gantt_data.R")
  source("../R/gantt_tufte.r")
  dat <- get_gantt_data(test_data = F)
  # str(dat)
  
  
  datin  <- dbGetQuery(ch,
  "
  select t1.container_task_title, 
  t2.*
  from container_task t1
  join work_package t2
  on t1.id = t2.container_id
  where t2.status != 'DONTSHOW'
  order by container_task_title"
  )
  #str(datin)
  datin_done  <- dbGetQuery(ch,
  "
  select t1.container_task_title, 
  t2.*
  from container_task_done t1
  join work_package_done t2
  on t1.id = t2.container_id
  where t2.status != 'DONTSHOW'
  "
  )
  #str(datin_done)
  datin  <- rbind(datin, datin_done)
   str(datin)
  str(dat)
  as.data.frame(table(datin$name))
  
  
  ```
  
  ```{r echo = F, results = "asis", eval = T}
  library("xtable")
  
  for(i in names(table(datin$name))){
   #i <-names(table(datin$name))[1]
  
   cat(i)
   cat("\n")
   cat("===\nTODO\n---\n")
   # str(dat)
   xdat <- sqldf(
   sprintf("select name, t1.container_task_narrow as task_group , t1.task_id,
   t2.start_date, t2.end_date, t2.efforti as effort_days, t1.notes, t2.status,
   case when t2.depends_on = t1.task_id then '' else t2.depends_on end as depends_on
   from datin t1
   left join
   dat t2
   on t1.task_id = t2.task_id
   where t1.name = '%s'
   order by t2.start_date
   ", i),
   drv = "SQLite")
    xdat$start_date <- as.character(format(xdat$start_date, "%A, %d-%b-%Y"))
    xdat$end_date <- as.character(format(xdat$end_date, "%A, %d-%b-%Y"))
   xdat1 <- subset(xdat, status == 'TODO')
   print(xtable(xdat1), type = "html", include.rownames = F)
  
   xdat2 <- subset(xdat, status == 'DONE')
   xdat2 <- xdat2[which(as.Date(xdat2$end_date, format = "%A, %d-%b-%Y") > Sys.Date() - 7),]
   # xdat2
   if(nrow(xdat2) > 0){
     cat("DONE\n---\n")  
     cat("\n")
     print(xtable(xdat2), type = "html", include.rownames = F)
     }
   }
  
  ```
  
    
#+end_src

#+RESULTS: make_html
*** COMMENT test2-code

| container_task_title | task_id                      | allocated | fte | blocker               |       start_date | effort | status | notes |
| no 1                 | Start                        | ivan      |   1 | NA                    |       2015-03-15 |     1d | DONE   | NA    |
| no 2                 | Repeat MEDLINE search        | ivan      |   1 | Start                 |       2015-03-16 |     5d | TODO   | NA    |
| no 3                 | Retrieve articles            | ivan      |   1 | Repeat MEDLINE search |               NA |     5d | TODO   | NA    |
| no 4                 | Read articles                | ivan      |   1 |                       |       2015-03-26 |    10d | TODO   |       |
| no 5                 | Summarize articles           | ivan      |   1 |                       |       2015-04-06 |     5d | TODO   |       |
| no 6                 | Write introduction           | ivan      |   1 |                       |       2015-04-11 |     5d | TODO   |       |
| no 7                 | Write methods                | ivan      |   1 | Start                 |                  |    10d | TODO   |       |
| no 8                 | Write results                | ivan      |   1 | Start                 |                  |    10d | TODO   |       |
| no 9                 | Write discussion             | ivan      |   1 | Write results         |                  |    10d | TODO   |       |
| no 10                | Send to co-author for review | ivan      |   1 | Write discussion      |                  |     2d | TODO   |       |
| no 11                | Revise draft 1               | ivan      |   1 |                       |       2015-04-30 |    10d | TODO   |       |
| no 12                | Submit article 1             | ivan      |   1 |                       |   Revise draft 1 |     5d | TODO   |       |
| no 13                | Revise draft 2               | ivan      |   1 |                       |       2015-05-30 |    10d | TODO   |       |
| no 14                | Submit article 2             | ivan      |   1 |                       |   Revise Draft 2 |     5d | TODO   |       |
| no 15                | Accepted                     | ivan      |   1 |                       | Submit article 2 |     1d | TODO   |       |

#+name:test2
#+begin_src R :session *R* :tangle no :exports none :eval yes
  #### name:test2####
  source("R/timebox.R")
  source("R/gantt_data_prep.R")
  source("R/gantt_tufte.r")
  
  datin  <- read.csv(
  textConnection("
  container_task_title  , task_id                      , allocated , fte , blocker               ,       start_date , effort , status , notes 
  01 Start              , Start                        , ivan      ,   1 , NA                    ,       2015-03-15 ,     1d , DONE   , NA    
  02 Update Lit Review  , Repeat MEDLINE search        , ivan      ,   1 , Start                 ,       2015-03-16 ,     5d , DONE   , NA    
  02 Update Lit Review  , Retrieve articles            , ivan      ,   1 , Repeat MEDLINE search ,               NA ,     5d , DONE   , NA    
  02 Update Lit Review  , Read articles                , ivan      ,   1 ,                       ,       2015-03-26 ,    11d , DONE   ,       
  02 Update Lit Review  , Summarize articles           , ivan      ,   1 ,                       ,       2015-04-06 ,     9d , TODO   ,       
  03 Write Draft        , Write introduction           , ivan      ,   1 ,                       ,       2015-04-09 ,     6d , TODO   ,       
  03 Write Draft        , Write methods                , ivan      ,   1 , Start                 ,                  ,    15d , TODO   ,       
  03 Write Draft        , Write results                , ivan      ,   1 ,                       ,       2015-03-30 ,    10d , TODO   ,       
  03 Write Draft        , Write discussion             , ivan      ,   1 ,                       ,       2015-04-15 ,    10d , TODO   ,       
  04 Internal Review    , Send to co-author for review , ivan      ,   1 , Write discussion      ,                  ,     2d , TODO   ,        
  04 Internal Review    , Revise draft 1               , ivan      ,   1 ,                       ,       2015-04-19 ,    10d , TODO   ,       
  05 Peer Review        , Submit article 1             , ivan      ,   1 , Revise draft 1        ,                  ,     5d , TODO   ,       
  06 Revise and Resubmit, Revise draft 2               , ivan      ,   1 ,                       ,       2015-04-30 ,    10d , TODO   ,       
  06 Revise and Resubmit, Submit article 2             , ivan      ,   1 , Revise draft 2        ,                  ,     5d , TODO   ,       
  07 End                , Accepted                     , ivan      ,   1 ,                       ,       2015-05-15 ,     1d , TODO   ,       
  "),
  stringsAsFactor = F, strip.white = T)
  # or 
  # datin <- get_gantt_data("gantt_todo", test_data = T) # need to
  # adjust min_context_xrange to 2015-01-01 or something
  datin$start_date  <- as.Date(datin$start_date)
  str(datin)
  datin
  
  dat_out <- gantt_data_prep(dat_in = datin)
  str(dat_out)
  dat_out
  #svg("tests/AAPL.svg",height=26,width=18)
  gantt_tufte(dat_out, focal_date = "2015-04-13", time_box = 3*7,
              min_context_xrange = "2015-03-16",
              cex_context_ylab = 0.65, cex_context_xlab = .7,
              cex_detail_ylab = 0.9,  cex_detail_xlab = .4,
              show_today = F)
  #dev.off()
  
#+end_src

#+RESULTS: test2

